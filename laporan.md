1. T1  Karakteristik sistem terdistribusi dan trade-off desain Pub-Sub aggregator
Jawaban: Sistem terdistribusi memiliki karakteristik utama: berbagi sumber daya, transparansi distribusi, keterbukaan, serta dependabilitas. Transparansi mencakup akses, lokasi, konkurensi, hingga replikasi, yang memungkinkan aplikasi melihat sistem seolah-olah satu kesatuan (Van Steen, 2023). Dalam konteks Pub-Sub aggregator, karakteristik ini menciptakan trade-off antara decoupling dan kompleksitas implementasi. Pub-sub menawarkan pemisahan kuat antara publisher dan subscriber, tetapi matching event dapat menjadi bottleneck terutama ketika subscription bersifat ekspresif atau berbasis atribut. Bab 1 menunjukkan bahwa matching yang tidak dapat didistribusikan secara efisien akan menurunkan skalabilitas (Van Steen, 2023). Karena itu, desain saya menggunakan topik hierarkis dan hashing sederhana untuk menjaga efisiensi. Hal ini menekan fleksibilitas tetapi meningkatkan throughput aggregator. Selain itu, kebutuhan temporal decoupling membuat middleware harus menyimpan notifikasi, sehingga menambah kebutuhan storage dan manajemen lease. Trade-off keseluruhan: semakin tinggi decoupling → semakin kompleks matching dan routing; semakin sederhana topik → semakin tinggi skalabilitas namun lebih terbatas ekspresivitas.

2. T2: Kapan memilih arsitektur publish-subscribe dibanding client-server?
Jawaban: Pub-sub dipilih ketika sistem membutuhkan event-driven communication dengan jumlah publisher/subscriber besar dan tingkat decoupling tinggi. Pub-sub memungkinkan publisher tidak mengetahui siapa subscriber aktif, sehingga cocok ketika konsumen data berubah-ubah atau bersifat dinamis (Van Steen, 2023). Client–server mengharuskan interaksi langsung dan sinkron, sehingga kurang cocok untuk workload broadcast, monitoring, IoT, atau sistem yang memproduksi event secara terus-menerus. Bab 2 menekankan bahwa pub-sub unggul dalam distribusi notifikasi dan multicast, terutama bila peristiwa harus dikirim ke banyak pihak secara efisien (Van Steen, 2023). Untuk rancangan aggregator saya, pub-sub dipilih karena kebutuhan streaming event real-time, retry, dan dedup lebih mudah diterapkan dibanding pola request–response. Selain itu, middleware pub-sub dapat menyimpan data sementara untuk melakukan explicit read oleh subscriber, sejalan dengan konsep temporal decoupling. Secara teknis, pub-sub lebih tepat ketika sistem membutuhkan skalabilitas horizontal, fan-out besar, dan latensi rendah antar event.

3. T3: At-least-once vs Exactly-once delivery; peran idempotent consumer
Jawaban: Bab 3 menjelaskan bahwa exactly-once tidak dapat dijamin dalam sistem terdistribusi karena crash dapat terjadi sebelum/ sesudah eksekusi, membuat status operasi tidak dapat dipastikan (Van Steen, 2023). Model at-least-once mengirim ulang permintaan hingga ada respons, tetapi dapat mengeksekusi lebih dari sekali. Karena retry tidak dapat dihindari, idempotent consumer menjadi mekanisme inti untuk memastikan efek akhir hanya terjadi sekali. Idempotensi dicapai dengan menyimpan event_id dan status eksekusi sehingga event duplikat diabaikan. Pendekatan ini memindahkan konsistensi dari jaringan ke logika aplikasi. Pada desain aggregator saya, setiap event dibubuhi event_id hashable dan diperiksa di dedup store sebelum diproses ulang. Dengan demikian, sistem memperoleh efektifitas exactly-once meskipun transport hanya memberikan at-least-once.

4. T4: Skema penamaan topic dan event_id (unik, collision-resistant) untuk dedup
Jawab: Topik dalam pub-sub umumnya direpresentasikan sebagai pasangan (atribut, nilai) atau hierarki string, sesuai konsep topic-based subscription (Van Steen, 2023). Untuk skalabilitas, bab 4 merekomendasikan hashing nama topik untuk membagi beban matching secara deterministik. Dalam desain aggregator saya, topik diberi struktur `<domain>/<entity>/<action>`, lalu di-hash untuk routing ke broker tertentu. Untuk dedup, event_id harus unik dan collision-resistant. Skema yang digunakan: `<topic>.<publisher>.<timestamp>.<counter>` kemudian di-hash SHA-256 untuk meminimalkan risiko tabrakan. Timestamp menyediakan ordering lemah, sedangkan counter mencegah tabrakan intra-millisecond. Dedup store menyimpan hash event_id sebagai kunci idempotensi.

5. T5: Ordering praktis (timestamp + monotonic counter);  batasan dan dampaknya
Jawaban: TOrdering global mustahil dicapai secara deterministik karena clock antar-node selalu mengalami skew (Van Steen, 2023). Solusi praktis adalah per-publisher ordering menggunakan timestamp lokal ditambah monotonic counter. Timestamp memberikan urutan kasar, sementara counter mencegah duplikasi saat timestamp sama. Pendekatan ini tidak menjamin global order, tetapi cukup untuk aggregator yang hanya mensyaratkan stabilitas hasil akhir. Batasan: clock skew menyebabkan misordering antar publisher; aggregator harus toleran terhadap ketidakteraturan tersebut. Dampaknya, konsumen harus menggunakan idempotensi dan toleransi terhadap reordering. Model ini sesuai sifat sistem terdistribusi: ordering sempurna mengorbankan performa dan daya serap event.

6. T6: Failure modes dan mitigasi
Jawaban: Bab 6 menjelaskan berbagai failure modes yang muncul dalam sistem terdistribusi, seperti crash failure, omission failure, timing failure, dan arbitrary (Byzantine) failure, yang masing-masing berdampak pada keandalan aliran event (Van Steen, 2023). Crash failure adalah mode paling umum, di mana proses berhenti tanpa memperbarui state. Omission failure muncul ketika pesan hilang atau tidak terkirim. Kedua mode ini sangat relevan untuk pipeline event pub-sub. Mitigasi utamanya adalah retry dengan exponential backoff, yang mengurangi beban jaringan dan mencegah retry storm. Untuk menghindari efek ganda akibat retry, sistem membutuhkan dedup store yang durable, sehingga jejak event yang sudah diproses tetap ada meskipun proses crash. Bab 6 menekankan pentingnya persistent state melalui teknik seperti logging dan checkpointing agar recovery dapat mengembalikan sistem ke state konsisten terbaru setelah kegagalan (Van Steen, 2023). Desain aggregator saya memanfaatkan write-ahead log, commit terurut, dan verifikasi event_id dalam dedup store sebelum eksekusi handler. Jika crash terjadi sebelum commit, event dapat diproses ulang; jika setelah commit, dedup mencegah duplikasi. Pendekatan ini menggabungkan retry, durability, dan recovery

7. T7: Eventual consistency pada aggregator; peran idempotency + dedup
Jawaban: Eventual consistency muncul karena event tiba dengan latensi berbeda, sementara global order tidak dapat dipaksakan tanpa biaya besar (Van Steen, 2023). Aggregator hanya menjamin bahwa setelah semua event diproses, state akan konvergen ke kondisi stabil. Idempotensi memastikan reprocessing tidak menciptakan efek ganda, sementara dedup mencegah duplikasi akibat retry. Bab 7 menekankan bahwa pub-sub bersifat temporally decoupled, sehingga ketidaksamaan waktu kedatangan adalah sifat alami. Desain aggregator saya bertumpu pada commit log dan idempotent reduce function, memastikan bahwa reordering dan retry tidak mengubah hasil akhir.

8. T8: Desain transaksi, ACID, dan menghindari lost-update
Jawaban: ACID mendefinisikan atomicity, consistency, isolation, dan durability (Van Steen, 2023). Isolation penting mencegah lost-update ketika beberapa event memodifikasi state yang sama. Strategi yang mampu menghindari lost-update: locking, optimistic concurrency control dengan version check, atau operasi atomik seperti upsert. Bab 8 menunjukkan bahwa transaksi dapat di-extend menjadi transactional RPC sehingga perubahan pada beberapa komponen tetap konsisten. Dalam desain aggregator, setiap read–modify–write dibungkus dalam satu transaksi database dengan isolation SERIALIZABLE untuk bagian kritis, sementara operasi agregasi besar menggunakan OCC agar throughput tetap tinggi. Ini menjaga konsistensi tanpa mengorbankan paralelisme.

9. T9: Kontrol konkurensi: locking, unique constraints, upsert, idempotent write
Jawaban: Kontrol konkurensi mencegah race condition antar worker. Unique constraints memastikan bahwa event dengan ID sama tidak dapat ditulis dua kali — pola ini mendukung idempotent writes. Locking atau selective serialization digunakan untuk state yang tidak dapat dikomodifikasi secara paralel. Upsert atomik mengikuti prinsip read-one write-all untuk menjaga konsistensi update (Van Steen, 2023). Desain aggregator saya menggabungkan dedup store dengan `INSERT ... ON CONFLICT DO NOTHING` atau `UPDATE ... WHERE version = old_version`. Pendekatan ini memastikan bahwa meskipun event diproses ulang akibat retry, konsistensi tidak rusak.

10. T10-13: Orkestrasi Compose, keamanan jaringan lokal, volume, observability
Jawaban: Compose menyediakan orkestrasi layanan yang meniru middleware terdistribusi — konsep yang dijelaskan pada Bab 10 saat middleware menyatukan antarmuka di seluruh node (Van Steen, 2023). Jaringan internal Compose dapat dibatasi untuk mencegah akses antar service yang tidak berkepentingan, sejalan dengan prinsip kontrol akses. Volume digunakan untuk menjaga durability karena transaksi membutuhkan penyimpanan yang tidak hilang saat crash. Observability diperlukan karena pub-sub rentan terhadap bottleneck di matching dan routing; log dan metrik harus memantau latensi, backlog, dan retry rate. Dengan orkestrasi Compose, service dapat dipisahkan, diuji, dan dipulihkan secara independen untuk meningkatkan dependabilitas.

Daftar Pustaka
Van Steen, M. (2023). Distributed Systems: Fourth Edition. MvS Publishing.