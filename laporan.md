1. T1  Karakteristik sistem terdistribusi dan trade-off desain Pub-Sub aggregator
Jawaban: Sistem terdistribusi dicirikan oleh berbagi sumber daya, transparansi distribusi, keterbukaan, serta dependability (availability, reliability, safety, maintainability). Transparansi meliputi akses, lokasi, konkurensi, hingga replikasi, sehingga pengguna melihat sistem seolah-olah satu kesatuan meski komponennya tersebar (Van Steen, 2023). Pada Pub-Sub aggregator, karakteristik tersebut memunculkan trade-off utama antara decoupling dan kompleksitas operasional. Pub-sub mengurangi coupling publisher–subscriber (publisher tidak perlu tahu konsumen), namun konsekuensinya sistem memerlukan mekanisme routing, buffering, dan kontrol backpressure. Semakin tinggi decoupling (spasial dan temporal), semakin besar kebutuhan middleware untuk menyimpan event saat subscriber lambat atau sementara tidak tersedia, yang meningkatkan biaya storage dan kompleksitas recovery. Selain itu, fan-out besar memperbesar tantangan observability: backlog, latensi end-to-end, serta duplikasi akibat retry harus dimonitor. Desain saya memilih topik yang sederhana (topic-based), worker paralel, serta dedup berbasis kunci unik di database untuk menjaga throughput dan kejelasan konsistensi. Trade-off yang diterima: ekspresivitas subscription tidak setinggi attribute-based matching, tetapi skalabilitas dan determinisme pemrosesan lebih mudah dicapai. (Van Steen, 2023)

2. T2: Kapan memilih arsitektur publish-subscribe dibanding client-server?
Jawaban: Arsitektur publish–subscribe dipilih ketika kebutuhan sistem bersifat event-driven, jumlah produsen/konsumen besar, dan relasi produsen–konsumen dinamis. Pub-sub mendukung loose coupling: publisher cukup “menyiarkan” event ke topik tanpa mengetahui subscriber mana yang aktif, sehingga cocok untuk monitoring, logging, stream processing, IoT, dan notifikasi multi-konsumen (Van Steen, 2023). Sebaliknya, client–server unggul ketika pola komunikasi dominan request–response, interaksi sinkron, dan konsumen relatif stabil; namun menjadi kurang efisien untuk pola broadcast/fan-out karena server harus melayani banyak klien secara langsung. Dalam rancangan aggregator saya, pub-sub dipilih karena aliran event kontinu dan kebutuhan retry + dedup lebih alami di pipeline asinkron: event dapat masuk ke broker/queue, lalu diproses worker secara paralel tanpa memaksa publisher menunggu seluruh proses selesai. Temporal decoupling memungkinkan aggregator menyerap burst traffic, sementara kontrol idempotensi mengatasi duplikasi akibat retry. Konsekuensi desain ini adalah kebutuhan manajemen backlog dan strategi pemulihan (re-delivery) yang jelas. Namun, untuk tujuan sistem log aggregator, pub-sub memberikan skalabilitas horizontal dan elastisitas yang lebih relevan dibanding client–server murni. (Van Steen, 2023)

3. T3: At-least-once vs Exactly-once delivery; peran idempotent consumer
Jawaban: Dalam sistem terdistribusi, “exactly-once” end-to-end sulit dijamin secara absolut karena crash dapat terjadi sebelum/ sesudah operasi berkomit, sehingga status eksekusi menjadi ambigu. Karena itu, banyak sistem memilih semantics at-least-once (pesan bisa dikirim ulang) dan memindahkan jaminan “efek sekali” ke lapisan aplikasi (Van Steen, 2023). At-least-once meningkatkan reliabilitas pengiriman, tetapi berisiko mengeksekusi event lebih dari sekali saat terjadi retry, timeout, atau re-delivery dari broker. Di sinilah idempotent consumer menjadi kunci: consumer harus memastikan bahwa memproses event yang sama berulang kali tidak mengubah state akhir lebih dari satu kali. Implementasi saya menegakkan idempotensi dengan kunci unik `(topic, event_id)` pada tabel hasil (processed), dan melakukan `INSERT ... ON CONFLICT DO NOTHING` untuk menolak duplikasi secara atomik. Dengan pola ini, meskipun transport/broker hanya menjamin at-least-once, efek bisnis di database mendekati “exactly-once” (tepatnya exactly-once effect pada penyimpanan). Trade-off-nya adalah kebutuhan penyimpanan state dedup (event_id) yang durable dan strategi penanganan “already processed” secara konsisten pada endpoint/worker. (Van Steen, 2023)

4. T4: Skema penamaan topic dan event_id (unik, collision-resistant) untuk dedup
Jawab: Pada model topic-based pub-sub, topik lazim direpresentasikan sebagai string yang mengelompokkan event berdasarkan domain fungsional (mis. `auth, payments, orders`). Skema ini memudahkan routing dan query, namun harus dijaga agar stabil dan konsisten antar publisher (Van Steen, 2023). Dalam desain saya, topik dibuat sederhana dan eksplisit agar matching cepat dan beban operasional rendah; fokus skalabilitas lebih ditekankan pada worker paralel dan pipeline asinkron dibanding subscription ekspresif. Untuk dedup, syarat utama adalah event_id unik dan tahan tabrakan. Cara yang paling praktis adalah memakai UUID v4 atau ID yang dibentuk dari kombinasi `(publisher_id, timestamp, nonce/counter)`. Implementasi saya mengasumsikan event_id berasal dari publisher (umumnya UUID), lalu sistem memaksa keunikan dengan constraint di database: `(topic, event_id)` menjadi primary key pada tabel hasil. Dengan demikian, collision pada event_id menjadi sangat kecil (secara probabilistik), sementara database menjadi otoritas final yang menolak duplikasi secara atomik. Mitigasi tambahan untuk integritas: validasi skema input (topic tidak kosong, event_id tidak kosong), serta logging pada kasus conflict agar metrik “duplicate_dropped” akurat. Ini membuat dedup kuat tanpa memerlukan koordinasi global antar publisher. (Van Steen, 2023)

5. T5: Ordering praktis (timestamp + monotonic counter);  batasan dan dampaknya
Jawaban: Ordering global yang sempurna sulit dicapai karena jam antar node mengalami drift dan skew; memaksakan total order biasanya mahal dan mengurangi throughput (Van Steen, 2023). Pendekatan praktis adalah menerima bahwa event dapat datang tidak berurutan, lalu menerapkan ordering yang “cukup” untuk kebutuhan bisnis. Skema umum adalah per-publisher ordering memakai timestamp lokal ditambah counter monotonik (atau sequence) untuk memecahkan tie ketika timestamp sama. Batasan utama: ordering lintas publisher tidak dapat dijamin, sehingga konsumen/aggregator harus toleran terhadap reordering. Dalam rancangan aggregator saya, ordering global tidak menjadi invariant utama; sistem lebih menekankan idempotensi dan ketahanan terhadap re-delivery, sehingga event yang sama tidak menggandakan efek walau diproses ulang atau datang terlambat. Dampaknya terhadap query `GET /events` adalah hasil dapat merepresentasikan urutan “hampir kronologis” berdasarkan kolom `ts`, tetapi tidak boleh diasumsikan sebagai total order lintas sumber. Mitigasi yang dipakai: menyimpan `ts` (timestamp event) terpisah dari `received_at/processed_at`, sehingga analisis dapat memilih basis urutan yang sesuai; dan memastikan operasi stateful (counter/stats) tidak bergantung pada ordering sempurna. Dengan demikian, sistem tetap stabil dan performa tinggi tanpa berusaha mencapai ordering ideal yang mahal. (Van Steen, 2023)

6. T6: Failure modes dan mitigasi
Jawaban: Bab 6 menjelaskan tentang failure modes seperti crash failure (proses berhenti), omission failure (pesan hilang/tidak terkirim), timing failure (lambat melewati batas waktu), dan kasus ekstrem arbitrary/Byzantine (Van Steen, 2023). Pada pipeline pub-sub, failure yang paling relevan biasanya crash dan omission/timing pada jaringan. Mitigasi standar adalah retry dengan backoff untuk menghindari retry storm, ditambah mekanisme re-delivery dari broker agar event tidak hilang. Namun retry memunculkan duplikasi, sehingga dedup/idempotensi wajib hadir sebagai “pengaman efek”. Dalam desain saya, event disalurkan via broker/queue lalu diproses worker; jika worker crash setelah menerima tetapi sebelum commit, event dapat diproses ulang. Karena itu, state dedup bersifat durable di database: kunci unik `(topic,event_id)` memastikan duplikasi tidak menghasilkan efek ganda. Untuk menjaga konsistensi metrik, update counter dilakukan dengan operasi atomik (upsert increment) dalam transaksi, sehingga crash tidak membuat counter meloncat tanpa commit. Selain itu, health/readiness endpoint dipakai untuk mendeteksi service yang belum siap (mis. DB/broker belum reachable) sehingga test dan orkestrasi tidak memaksa request saat dependency belum sehat. Trade-off mitigasi ini adalah tambahan latensi pada jalur tulis (cek/insert dedup + transaksi), tetapi menghasilkan perilaku yang lebih deterministik di bawah kegagalan. (Van Steen, 2023)

7. T7: Eventual consistency pada aggregator; peran idempotency + dedup
Jawaban: Eventual consistency muncul ketika komponen terdistribusi memproses event secara asinkron dan tidak ada total order global. Dalam pub-sub, temporal decoupling membuat event dapat tertahan di broker/backlog dan diproses belakangan, sehingga state sistem berkonvergensi setelah semua event “akhirnya” diproses (Van Steen, 2023). Desain aggregator saya bersifat asinkron: endpoint `POST /publish` menerima event, lalu worker memproses dan menulis hasil ke storage. Karena ada re-delivery dan retry, sistem menerima bahwa event bisa muncul lebih dari sekali dan urutan kedatangan tidak stabil. Dua mekanisme yang memastikan konvergensi adalah idempotensi dan dedup kuat. Idempotensi memastikan pemrosesan ulang tidak mengubah state akhir lebih dari sekali; dedup menolak duplikasi secara atomik dengan constraint unik di database. Dengan demikian, walau pembacaan `GET /stats` atau `GET /events` sesaat setelah publish bisa belum mencerminkan semua event (karena backlog), pada akhirnya data akan konsisten ketika worker mengejar backlog. Trade-off-nya adalah “read-your-writes” tidak selalu langsung terpenuhi untuk publish tertentu; mitigasinya adalah readiness/stats yang jelas, serta desain test yang menunggu kondisi stabil (polling dengan timeout) sebelum melakukan assert. Ini selaras dengan karakter sistem terdistribusi: konsistensi kuat real-time biasanya mengorbankan throughput dan availability. (Van Steen, 2023)

8. T8: Desain transaksi, ACID, dan menghindari lost-update
Jawaban: ACID menuntut atomicity (all-or-nothing), consistency (invariant terjaga), isolation (seolah serial), dan durability (commit tidak hilang) (Van Steen, 2023). Pada aggregator, risiko utama adalah lost-update dan inkonsistensi counter ketika beberapa worker menulis bersamaan. Implementasi saya menggunakan transaksi database untuk menggabungkan: insert event hasil (processed), update status dedup, dan update counter secara atomik. Untuk isolation, saya memilih READ COMMITTED karena cukup bila operasi kritis dirancang sebagai single-statement atomic writes (mis. upsert increment) dan dedup ditegakkan oleh constraint unik. Trade-off READ COMMITTED: mencegah dirty reads, namun tetap memungkinkan non-repeatable reads dan phantom reads; lost-update masih bisa terjadi jika aplikasi melakukan pola read–modify–write tanpa proteksi. Mitigasinya: (1) gunakan `INSERT ... ON CONFLICT DO NOTHING` untuk idempotent insert, (2) gunakan `ON CONFLICT DO UPDATE SET value = value + EXCLUDED.value` untuk counter agar tidak memakai read–modify–write terpisah, (3) minimalkan scope transaksi dan hindari membaca lalu menghitung di aplikasi sebelum update. Jika pada bagian tertentu dibutuhkan perlindungan lebih kuat (mis. invariant kompleks lintas baris), opsi naik ke SERIALIZABLE tersedia, dengan trade-off meningkatnya serialization failure; mitigasinya adalah retry transaksi dengan backoff. (Van Steen, 2023)

9. T9: Kontrol konkurensi: locking, unique constraints, upsert, idempotent write
Jawaban: Kontrol konkurensi bertujuan mencegah race condition antar worker yang memproses event paralel (Van Steen, 2023). Dalam desain saya, mekanisme inti adalah unique constraint pada pasangan `(topic, event_id)` yang menjamin event yang sama tidak bisa “terhitung” dua kali pada tabel hasil. Ini membentuk idempotent write di level database: duplikasi tidak memerlukan lock aplikasi, cukup `INSERT ... ON CONFLICT DO NOTHING`. Untuk state agregat seperti counter, saya memakai upsert atomik (increment di sisi database) agar tidak terjadi lost-update akibat dua worker membaca nilai lama lalu menulis nilai baru. Trade-off pendekatan constraint+upsert: konsistensi kuat dicapai tanpa locking eksplisit, tetapi tetap perlu memikirkan anomali baca (phantom/non-repeatable) bila endpoint query membuat asumsi “snapshot” stabil. Mitigasinya adalah mendesain query sebagai operasi read-only yang toleran terhadap perubahan (mis. pagination dengan limit/offset) dan menghindari asumsi bahwa dua pembacaan berurutan akan identik di bawah load. Jika suatu invariants membutuhkan serial execution, locking selektif (row-level lock) atau SERIALIZABLE dapat digunakan; trade-off-nya adalah throughput turun dan potensi deadlock/serialization error. Mitigasi untuk SERIALIZABLE adalah retry-on-failure dengan batas percobaan dan backoff, serta membatasi bagian transaksi yang benar-benar perlu isolasi kuat. (Van Steen, 2023)

10. T10-13: Orkestrasi Compose, keamanan jaringan lokal, volume, observability
Jawaban: Orkestrasi layanan membantu mensimulasikan lingkungan terdistribusi yang realistis: service dipisah, dependency dinyatakan eksplisit, dan recovery dapat diuji per-komponen. Ini selaras dengan konsep middleware/komponen perantara yang menyatukan antarmuka di berbagai node (Van Steen, 2023). Dalam implementasi saya, Compose dipakai untuk menjalankan `aggregator`, `broker`, dan `storage` pada jaringan lokal yang terisolasi; port yang diekspos hanya yang diperlukan (mis. API aggregator). Praktik ini mengurangi permukaan serangan dan mencegah akses tidak sengaja antar service. Untuk persistensi, named volumes pada Postgres/Redis memastikan durability: data tetap ada meskipun container direcreate, yang penting untuk dedup store dan counter. Observability menjadi krusial karena pub-sub rawan backlog dan duplikasi; metrik minimal mencakup jumlah event masuk, jumlah unik diproses, jumlah duplikat ditolak, latensi pemrosesan, serta kedalaman backlog. Health/readiness endpoint dipakai untuk menegakkan dependency sehat sebelum test berjalan, sehingga kegagalan test lebih merefleksikan bug logika dibanding masalah startup. Trade-off orkestrasi adalah kompleksitas setup, tetapi ini sepadan untuk validasi end-to-end (integration test) dan demonstrasi dependability pada sistem terdistribusi. (Van Steen, 2023)

Link youtube: https://youtu.be/-sMiujFXOSI
Daftar Pustaka
Van Steen, M. (2023). Distributed Systems: Fourth Edition. MvS Publishing.